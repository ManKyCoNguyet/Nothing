<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SGU Christmas Full Effects</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive, sans-serif;
        }

        #fireworks-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100vh;
            z-index: 20; transition: opacity 1s ease-out;
        }

        #tree-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100vh;
            z-index: 10; opacity: 0; transition: opacity 2s ease-in;
        }

        #tree-canvas {
            display: block; position: absolute; top: 0; left: 0; z-index: 1;
        }

        #message-container {
            position: absolute; bottom: 8%; left: 50%; transform: translateX(-50%);
            text-align: center; z-index: 10; pointer-events: none; width: 100%;
        }

        h1 {
            font-size: 3rem; color: #FFF8DC; margin: 0; letter-spacing: 2px;
            text-shadow: 0 0 5px #FFFFFF, 0 0 15px #FFD700, 0 0 25px #DAA520;
            opacity: 0; transition: opacity 3s ease-in-out; 
            animation: sparkleText 3s infinite alternate;
        }

        h1.show { opacity: 1; }
        @keyframes sparkleText {
            0% { text-shadow: 0 0 5px #FFFFFF, 0 0 10px #FFD700; }
            100% { text-shadow: 0 0 10px #FFFFFF, 0 0 20px #FFD700, 0 0 30px #DAA520; }
        }
    </style>
</head>
<body>
    <div id="fireworks-container"></div>
    <div id="tree-layer">
        <div id="message-container"><h1 id="merry-text">Merry Christmas</h1></div>
        <canvas id="tree-canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const fwContainer = document.getElementById('fireworks-container');
        const treeLayer = document.getElementById('tree-layer');
        let stopSpawningFireworks = false;
        let isTreeSceneActive = false;
        let threeJsLoopId = null; 

        setTimeout(() => { stopSpawningFireworks = true; }, 5000);

        function checkAndSwitchScene(activeFireworksCount) {
            if (stopSpawningFireworks && activeFireworksCount === 0 && !isTreeSceneActive) {
                isTreeSceneActive = true;
                if(threeJsLoopId) cancelAnimationFrame(threeJsLoopId);
                fwContainer.style.opacity = '0';
                setTimeout(() => { fwContainer.style.display = 'none'; }, 1000);
                treeLayer.style.opacity = '1';
                startTreeLogic(); 
            }
        }

        (function() {
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.z = 140; camera.position.y = 10;
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            fwContainer.appendChild(renderer.domElement);

            const heartPointsRaw = []; const textPointsRaw = [];

            function precompute() {
                let generated = 0;
                while (generated < 10000) {
                    const t = Math.random() * Math.PI * 2;
                    if (Math.random() > Math.abs(Math.sin(t)) + 0.01) continue;
                    let x = (16 * Math.pow(Math.sin(t), 3));
                    let y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    const r = Math.pow(Math.random(), 0.6) * 2.8;
                    const c1 = new THREE.Color('#00ccff'); const c2 = new THREE.Color('#0033aa');
                    const c = c1.clone().lerp(c2, Math.random());
                    heartPointsRaw.push({ ox: x*r, oy: y*r, oz: (Math.random()-0.5)*10, r: c.r, g: c.g, b: c.b });
                    generated++;
                }
                const cvs = document.createElement('canvas'); const ctx = cvs.getContext('2d');
                cvs.width = 800; cvs.height = 300;
                ctx.fillStyle = '#FFF'; ctx.font = 'Bold 55px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText("Merry Christmas SGU!", 400, 150);
                const data = ctx.getImageData(0,0,800,300).data;
                for(let y=0; y<300; y+=2) {
                    for(let x=0; x<800; x+=2) {
                        if(data[(y*800+x)*4+3] > 128) {
                            textPointsRaw.push({ ox: (x-400)*0.12, oy: -(y-150)*0.12, oz: 3+Math.random()*2, r:1, g:1, b:1 });
                        }
                    }
                }
            }
            precompute();

            class Rocket {
                constructor(sx, sz) {
                    const geo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([0,0,0],3));
                    const mat = new THREE.PointsMaterial({color:0xffffff, size:3, blending:THREE.AdditiveBlending});
                    this.mesh = new THREE.Points(geo, mat);
                    this.mesh.position.set(sx, -110, sz);
                    scene.add(this.mesh);
                    this.sy = 3.8+Math.random()*0.5; this.vx=(Math.random()-0.5)*0.3; this.vz=(Math.random()-0.5)*0.3;
                    this.active = true;
                    this.trail = []; 
                    this.tGeo = new THREE.BufferGeometry();
                    this.tGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(4500), 3));
                    this.tGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(4500), 3));
                    this.tMat = new THREE.PointsMaterial({size:1.2, vertexColors:true, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending, depthWrite:false});
                    this.tMesh = new THREE.Points(this.tGeo, this.tMat);
                    scene.add(this.tMesh);
                }
                update() {
                    if(!this.active) {
                        this.updateTrail(false);
                        if(this.trail.length===0) { scene.remove(this.tMesh); return 'DONE'; }
                        return 'FADING';
                    }
                    this.sy *= 0.96; this.vx *= 0.95; this.vz *= 0.95;
                    this.mesh.position.x += this.vx; this.mesh.position.y += this.sy; this.mesh.position.z += this.vz;
                    this.updateTrail(true);
                    if(this.sy < 0.15) { scene.remove(this.mesh); this.active = false; return 'PEAK'; }
                    return 'FLY';
                }
                updateTrail(spawn) {
                    if(spawn) {
                        for(let i=0; i<Math.floor(this.sy*2)+1; i++) 
                            this.trail.push({x:this.mesh.position.x+(Math.random()-0.5), y:this.mesh.position.y+(Math.random()-0.5), z:this.mesh.position.z+(Math.random()-0.5), l:1, vx:this.vx*0.2, vy:-0.1, vz:this.vz*0.2});
                    }
                    const pos = this.tMesh.geometry.attributes.position.array;
                    const col = this.tMesh.geometry.attributes.color.array;
                    let c=0;
                    for(let i=this.trail.length-1; i>=0; i--) {
                        const p = this.trail[i]; p.l -= 0.03; p.x+=p.vx; p.y+=p.vy; p.z+=p.vz;
                        if(p.l<=0) this.trail.splice(i,1);
                        else {
                            pos[c*3]=p.x; pos[c*3+1]=p.y; pos[c*3+2]=p.z;
                            col[c*3]=col[c*3+1]=col[c*3+2]=p.l*0.8; c++;
                        }
                    }
                    this.tMesh.geometry.setDrawRange(0, c);
                    this.tMesh.geometry.attributes.position.needsUpdate = true;
                    this.tMesh.geometry.attributes.color.needsUpdate = true;
                }
            }

            class Explosion {
                constructor(pos) {
                    this.cPos = pos; this.parts = [];
                    const geo = new THREE.BufferGeometry();
                    const pArr = []; const cArr = [];
                    
                    const addPart = (raw, isTxt) => {
                        const tx = raw.ox + pos.x; const ty = raw.oy + pos.y; const tz = raw.oz + pos.z;
                        const sx = pos.x + (Math.random()-0.5)*20;
                        const sy = pos.y + (Math.random()-0.5)*20;
                        const sz = pos.z + (Math.random()-0.5)*20;
                        pArr.push(sx,sy,sz); cArr.push(raw.r, raw.g, raw.b);
                        
                        this.parts.push({
                            tx: tx, ty: ty, tz: tz,
                            cx: sx, cy: sy, cz: sz,
                            vx: raw.ox*0.15*(0.8+Math.random()*0.4), 
                            vy: raw.oy*0.15*(0.8+Math.random()*0.4), 
                            vz: raw.oz*0.15*(0.8+Math.random()*0.4),
                            life: 0.8+Math.random()*0.7, 
                            fric: isTxt ? 0.95 : (0.91 + Math.random() * 0.04)
                        });
                    }
                    heartPointsRaw.forEach(p => addPart(p, false));
                    textPointsRaw.forEach(p => addPart(p, true));
                    
                    geo.setAttribute('position', new THREE.Float32BufferAttribute(pArr, 3));
                    geo.setAttribute('color', new THREE.Float32BufferAttribute(cArr, 3));
                    this.mat = new THREE.PointsMaterial({size:0.5, vertexColors:true, transparent:true, opacity:0.1, blending:THREE.AdditiveBlending, depthWrite:false});
                    this.mesh = new THREE.Points(geo, this.mat);
                    scene.add(this.mesh);
                    this.phase = 'form'; this.timer = 0;
                }
                update() {
                    const pos = this.mesh.geometry.attributes.position.array;
                    if(this.phase === 'form') {
                        this.timer++;
                        if(this.mat.opacity < 1) this.mat.opacity += 0.08;
                        let maxD = 0;
                        for(let i=0; i<this.parts.length; i++) {
                            const p = this.parts[i];
                            p.cx += (p.tx - p.cx) * 0.15;
                            p.cy += (p.ty - p.cy) * 0.15;
                            p.cz += (p.tz - p.cz) * 0.15;
                            pos[i*3] = p.cx; pos[i*3+1] = p.cy; pos[i*3+2] = p.cz;
                            const d = Math.abs(p.tx-p.cx)+Math.abs(p.ty-p.cy)+Math.abs(p.tz-p.cz);
                            if(d>maxD) maxD=d;
                        }
                        this.mesh.geometry.attributes.position.needsUpdate = true;
                        if(maxD < 0.5 || this.timer > 30) this.phase = 'hover';
                        return true;
                    } 
                    else if (this.phase === 'hover') {
                        for(let i=0; i<this.parts.length; i++) {
                            const p = this.parts[i];
                            p.cy += 0.02; 
                            pos[i*3] = p.cx; pos[i*3+1] = p.cy; pos[i*3+2] = p.cz;
                        }
                        this.mesh.geometry.attributes.position.needsUpdate = true;
                        return true;
                    }
                    else if (this.phase === 'explode') {
                        let active = 0;
                        for(let i=0; i<this.parts.length; i++) {
                            const p = this.parts[i];
                            if(p.life > 0) {
                                p.vx *= p.fric; p.vy *= p.fric; p.vz *= p.fric;
                                p.vy -= 0.05; 
                                p.cx += p.vx; p.cy += p.vy; p.cz += p.vz;
                                pos[i*3] = p.cx; pos[i*3+1] = p.cy; pos[i*3+2] = p.cz;
                                p.life -= 0.01; active++;
                            } else pos[i*3] = 99999;
                        }
                        this.mesh.geometry.attributes.position.needsUpdate = true;
                        if(active < this.parts.length/2) this.mat.opacity *= 0.97;
                        return active > 0 && this.mat.opacity > 0.05;
                    }
                }
            }

            const activeFW = []; let fc = 0;
            
            function loop() {
                if (isTreeSceneActive) return;
                threeJsLoopId = requestAnimationFrame(loop);
                fc++;
                
                if (!stopSpawningFireworks) {
                    if (fc === 10) activeFW.push(new Rocket(0,0));
                    if (fc === 100) activeFW.push(new Rocket(-50,-20));
                    if (fc === 200) activeFW.push(new Rocket(50,20));
                    if (fc > 300 && fc % 80 === 0) activeFW.push(new Rocket((Math.random()-0.5)*140, (Math.random()-0.5)*60));
                }

                for(let i=activeFW.length-1; i>=0; i--) {
                    const res = activeFW[i].update();
                    if(res === 'DONE' && activeFW[i].isDead) activeFW.splice(i,1);
                    else if (res === 'PEAK') {
                        activeFW[i].explosion = new Explosion(activeFW[i].mesh.position);
                        activeFW[i].phase = 'DISP'; activeFW[i].timer = 0;
                    } else if (activeFW[i].phase === 'DISP') {
                        activeFW[i].explosion.update(); activeFW[i].timer++;
                        if(activeFW[i].timer > 40) { 
                             activeFW[i].explosion.phase = 'explode'; activeFW[i].phase = 'EXP'; 
                        }
                    } else if (activeFW[i].phase === 'EXP') {
                        if(!activeFW[i].explosion.update()) {
                            activeFW[i].explosion.mesh.geometry.dispose();
                            activeFW[i].explosion.mat.dispose();
                            scene.remove(activeFW[i].explosion.mesh);
                            activeFW[i].phase = 'DONE'; activeFW[i].isDead = true;
                        }
                    }
                }
                renderer.render(scene, camera);
                checkAndSwitchScene(activeFW.length);
            }
            loop();
            window.addEventListener('resize', ()=>{
                if(!isTreeSceneActive) {
                    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        })();

        function startTreeLogic() {
            const cvs = document.getElementById('tree-canvas');
            const ctx = cvs.getContext('2d');
            const msg = document.getElementById('merry-text');
            const startTime = Date.now();
            const SNOW_WAIT = 3500; 

            let w, h;
            const parts = [], snows = [], grounds = [];
            const cfg = { tw: 350, th: 650, layers: 9, speed: 0.3, ground: 350 }; 

            const cols = [{r:10,g:90,b:40}, {r:30,g:120,b:60}, {r:160,g:110,b:60}, {r:255,g:215,b:0}, {r:240,g:240,b:255}, {r:220,g:30,b:50}];
            const ornCols = [{r:150,g:10,b:40}, {r:255,g:215,b:0}, {r:40,g:160,b:60}, {r:230,g:230,b:255}];

            let revealY = 0; let starOn = false; let starT = 0; let msgOn = false;
            let currentRot = 0; 

            function resize() {
                w = cvs.width = window.innerWidth; h = cvs.height = window.innerHeight;
                cfg.th = h * 0.85; cfg.tw = Math.min(w, h) * 0.52; cfg.ground = cfg.th/2 + 20;
                revealY = cfg.th/2 + 150; starOn = false; starT = 0; msgOn = false; msg.classList.remove('show');
                initSnow(); initGround();
            }
            window.addEventListener('resize', resize);
            function lerp(a,b,t) { return a*(1-t)+b*t; }

            class Ground {
                constructor() { this.reset(); }
                reset() {
                    const r = Math.sqrt(Math.random()) * cfg.tw; const a = Math.random()*Math.PI*2;
                    this.lx = Math.cos(a)*r; this.ly = cfg.ground; this.lz = Math.sin(a)*r;
                    this.c = cols[Math.floor(Math.random()*cols.length)];
                    this.s = Math.random()*2+0.5; 
                    this.tba = Math.random()*0.5+0.2; 
                    this.cba = 0;
                    this.a = 0;
                    this.ps = 1 + Math.random(); this.po = Math.random()*Math.PI*2;
                }
                update(dt, t) {
                    if(this.cba < this.tba) {
                        this.cba += 0.3 * dt;
                        if(this.cba > this.tba) this.cba = this.tba;
                    }
                    this.a = this.cba + Math.sin(t*this.ps + this.po)*0.15; 
                    if(this.a<0) this.a=0; 
                }
                draw(ctx,cx,cy,rot) {
                    const rx = this.lx*Math.cos(rot) - this.lz*Math.sin(rot);
                    const rz = this.lx*Math.sin(rot) + this.lz*Math.cos(rot);
                    const sc = 350/(350+rz+450); if(sc<0) return;
                    ctx.beginPath(); ctx.arc(cx+rx*sc, cy+this.ly*sc, this.s*sc, 0, Math.PI*2);
                    ctx.fillStyle=`rgba(${this.c.r},${this.c.g},${this.c.b},${this.a})`; ctx.fill();
                }
            }
            function initGround() { grounds.length=0; for(let i=0; i<800; i++) grounds.push(new Ground()); }

            class Snow {
                constructor() { this.reset(true); }
                reset(init) {
                    const tt = -cfg.th/2 - 100; const tb = cfg.th/2 + 100;
                    this.y = init ? tt + Math.random()*(tb-tt) : tt;
                    let hr = (this.y-tt)/(tb-tt); hr = Math.max(0,Math.min(1,hr));
                    this.sz = 1 + Math.random()*1.5 + (hr*hr*3.5);
                    const minR = cfg.tw/2+30; const maxR = Math.max(w,h)*0.7;
                    this.r = minR + (Math.random()*lerp(0.8,0.2,hr))*(maxR-minR);
                    this.a = Math.random()*Math.PI*2;
                    this.sy = 30 + Math.random()*60 + hr*90; 
                    this.rs = 0.2 + Math.random()*0.3; 
                    this.op = 0.3 + Math.random()*0.7;
                }
                update(dt) {
                    this.y += this.sy * dt; 
                    this.a += this.rs * dt;
                    if(this.y > cfg.th/2+100) this.reset();
                }
                draw(ctx,cx,cy,rot) {
                    const mr = (rot*0.1) + this.a;
                    const rx = Math.cos(mr)*this.r; const rz = Math.sin(mr)*this.r;
                    const sc = 350/(350+rz+450); if(sc<0.1) return;
                    ctx.beginPath(); ctx.arc(cx+rx*sc, cy+this.y*sc, this.sz*sc, 0, Math.PI*2);
                    ctx.fillStyle=`rgba(255,255,255,${this.op * Math.min(1, sc*1.2)})`; ctx.fill();
                }
            }
            function initSnow() { snows.length=0; for(let i=0; i<300; i++) snows.push(new Snow()); }

            class Part {
                constructor() {
                    const r = Math.random(); this.isO = r<0.007; this.isG = !this.isO && r<0.010;
                    this.reset(true);
                }
                reset() {
                    let lp = Math.pow(Math.random(), 0.4);
                    let pil = (this.isO||this.isG) ? 0.7+Math.random()*0.3 : (lp*cfg.layers)%1;
                    let br = cfg.tw*lp*0.5; let lr = br*(0.3+2.0*pil);
                    this.a = Math.random()*Math.PI*2;
                    this.lx = Math.cos(this.a)*lr; this.ly = (lp-0.5)*cfg.th; this.lz = Math.sin(this.a)*lr;
                    
                    if(this.isO) { this.c = ornCols[Math.floor(Math.random()*ornCols.length)]; this.sz = Math.random()*4+5; this.ta=1; }
                    else if(this.isG) { 
                        this.bc='#FFD700'; this.rc='#B22222'; this.sz=Math.random()*4+4; this.ta=1; 
                    }
                    else { this.c = cols[Math.floor(Math.random()*cols.length)]; this.sz=Math.random()*2+0.5; this.ta=Math.random()*0.6+0.4; }
                    
                    this.al=0; this.fs = 0.5 + Math.random(); 
                    this.fall = false; this.gnd = false; this.gl = 300; 
                    this.fsp = 120 + Math.random()*120; 
                }
                update(dt, timeSec) {
                    const ca = this.a + currentRot;
                    const trig = revealY + Math.sin(ca)*60;
                    const can = this.ly > trig;

                    if(can && this.al < this.ta && !this.gnd) this.al += this.fs * dt;
                    
                    if((this.isO||this.isG) && this.fall) this.fall=false;

                    if(this.fall) {
                        this.ly += this.fsp * dt;
                        this.lx += Math.sin(timeSec + this.lz)*10 * dt; 
                        this.lz += Math.cos(timeSec + this.lx)*10 * dt;
                        if(this.ly >= cfg.ground) { this.ly = cfg.ground; this.fall=false; this.gnd=true; }
                    } else if(this.gnd) {
                        this.gl--; if(this.gl<50) this.al -= 1.0 * dt;
                        if(this.gl<0 || this.al<=0) this.reset();
                    } else {
                        if(!this.isO && !this.isG && can && this.al>0.4 && Math.random() < 0.002 * (dt*60)) this.fall=true;
                    }
                }
                
                draw(ctx,cx,cy,rot) {
                    if(this.al<=0) return;
                    const rx = this.lx*Math.cos(rot)-this.lz*Math.sin(rot);
                    const rz = this.lx*Math.sin(rot)+this.lz*Math.cos(rot);
                    const sc = 350/(350+rz+450); if(sc<0) return;
                    const sz = this.sz*sc;
                    ctx.save(); ctx.translate(cx+rx*sc, cy+this.ly*sc);

                    if(this.isG) {
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.rotate(rot*0.5); 
                        const bs = sz*1.8; 
                        const rw = bs*0.3;

                        ctx.fillStyle = this.bc; 
                        ctx.globalAlpha = this.al; 
                        ctx.fillRect(-bs/2, -bs/2, bs, bs);

                        ctx.fillStyle = this.rc; 
                        ctx.fillRect(-rw/2, -bs/2, rw, bs); 
                        ctx.fillRect(-bs/2, -rw/2, bs, rw); 

                        ctx.beginPath(); 
                        ctx.arc(0, 0, rw*0.8, 0, Math.PI*2); 
                        ctx.fill();

                        ctx.globalCompositeOperation = 'lighter';
                    } else if(this.isO) {
                        // Vẽ quả châu
                        const isGold = this.c.r===255 && this.c.g===215;
                        if(isGold) { ctx.shadowColor=`rgba(255,215,0,${this.al})`; ctx.shadowBlur=25*sc; }
                        const g = ctx.createRadialGradient(-sz*0.3,-sz*0.3,sz*0.1,0,0,sz*1.1);
                        g.addColorStop(0,`rgba(255,255,255,${this.al})`);
                        g.addColorStop(0.5,`rgba(${this.c.r},${this.c.g},${this.c.b},${this.al*0.9})`);
                        g.addColorStop(1,`rgba(${this.c.r*0.6},${this.c.g*0.6},${this.c.b*0.6},${this.al})`);
                        ctx.beginPath(); ctx.arc(0,0,sz*1.1,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();
                        if(isGold) ctx.shadowBlur=0;
                        
                        // Điểm sáng trên quả châu
                        ctx.beginPath();
                        ctx.ellipse(-sz*0.35, -sz*0.35, sz*0.2, sz*0.12, Math.PI/4, 0, Math.PI*2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.al})`; 
                        ctx.fill();
                    } else {
                        // Vẽ lá cây (đốm sáng)
                        const dsz = this.gnd ? sz*1.2 : sz;
                        ctx.beginPath(); ctx.arc(0,0,dsz,0,Math.PI*2);
                        ctx.fillStyle=`rgba(${this.c.r},${this.c.g},${this.c.b},${this.al})`; ctx.fill();
                    }
                    ctx.restore();
                }
            }
            for(let i=0; i<3800; i++) parts.push(new Part());

            function drawStar(cx, cy, t) {
                const rot = -Math.PI/2; const sc = 1 + (Math.sin(t*5)*0.15*starT);
                const or = 26*sc; const ir = 12*sc; 
                const psc = 350/(350+450); const sy = cy + (-cfg.th/2)*psc + 5;
                ctx.save(); ctx.translate(cx, sy); ctx.rotate(Math.sin(t*2)*0.1);
                ctx.beginPath();
                for(let i=0; i<5; i++) {
                    ctx.lineTo(Math.cos(rot+i*Math.PI*2/5)*or, Math.sin(rot+i*Math.PI*2/5)*or);
                    ctx.lineTo(Math.cos(rot+i*Math.PI*2/5+Math.PI/5)*ir, Math.sin(rot+i*Math.PI*2/5+Math.PI/5)*ir);
                }
                ctx.closePath();
                const g = ctx.createRadialGradient(0,0,0,0,0,or);
                const cr = lerp(210,255,starT); const cg = lerp(180,255,starT); const cb = lerp(120,255,starT);
                g.addColorStop(0, `rgb(${cr},${cg},${cb})`); g.addColorStop(1, `rgb(255,235,100)`);
                ctx.shadowBlur = lerp(0,50,starT)*sc; ctx.shadowColor="#FFE570"; ctx.fillStyle=g; ctx.fill(); ctx.restore();
            }

            resize();

            let lastTime = Date.now();
            function animate() {
                requestAnimationFrame(animate);
                const now = Date.now();
                const dt = (now - lastTime) / 1000; 
                lastTime = now;
                const elapsed = now - startTime;
                const timeSec = now * 0.001; 

                const shouldGrow = elapsed > SNOW_WAIT;

                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,w,h);
                const cx = w/2; const cy = h/2;

                currentRot += cfg.speed * dt;

                ctx.globalCompositeOperation = 'source-over';
                snows.forEach(s => { s.update(dt); s.draw(ctx,cx,cy,currentRot); });

                if(shouldGrow) {
                    const treeTop = -cfg.th/2;
                    let growSpeed = (0.5 + 2.5 * Math.max(0, Math.min(1, (revealY-treeTop)/(cfg.th+150)))) * 150 * dt;
                    if(revealY > treeTop-50) revealY -= growSpeed;
                    if(revealY <= treeTop+50) starOn = true;
                    if(starOn && starT<1) { starT += 0.5 * dt; if(starT>1) starT=1; }
                    if(starT>=1 && !msgOn) { msg.classList.add('show'); msgOn=true; }

                    ctx.globalCompositeOperation = 'lighter';
                    // Cập nhật Ground với dt và timeSec để fade-in
                    grounds.forEach(g => { g.update(dt, timeSec); g.draw(ctx,cx,cy,currentRot); });
                    parts.forEach(p => { p.update(dt, timeSec); p.draw(ctx,cx,cy,currentRot); });

                    ctx.globalCompositeOperation = 'source-over';
                    drawStar(cx,cy,timeSec);
                }
            }
            animate();
        }
    </script>
</body>
</html>