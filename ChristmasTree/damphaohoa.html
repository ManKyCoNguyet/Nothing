<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SGU Fireworks - Harmonious Density</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.z = 140;
        camera.position.y = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const heartPointsRaw = [];
        const textPointsRaw = [];

        function precomputeGeometry() {
            const heartCount = 10000;
            let pointsGenerated = 0;
            while (pointsGenerated < heartCount) {
                const t = Math.random() * Math.PI * 2;
                
                if (Math.random() > Math.abs(Math.sin(t)) + 0.01) {
                    continue;
                }

                let xBase = 16 * Math.pow(Math.sin(t), 3);
                let yBase = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);

                const r = Math.pow(Math.random(), 0.6) * 2.8; 
                
                let x = xBase * r; let y = yBase * r; let z = (Math.random() - 0.5) * 10; 
                const c1 = new THREE.Color('#00ccff'); const c2 = new THREE.Color('#0033aa');
                const color = c1.clone().lerp(c2, Math.random());
                
                heartPointsRaw.push({ ox: x, oy: y, oz: z, r: color.r, g: color.g, b: color.b });
                pointsGenerated++;
            }

            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 800; canvas.height = 300;
            ctx.fillStyle = '#FFFFFF'; ctx.font = 'Bold 55px Arial, sans-serif'; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText("Merry Christmas SGU!", canvas.width / 2, canvas.height / 2);
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            for (let y = 0; y < canvas.height; y += 2) { 
                for (let x = 0; x < canvas.width; x += 2) {
                    if (imgData[(y * canvas.width + x) * 4 + 3] > 128) {
                        textPointsRaw.push({ 
                            ox: (x - canvas.width / 2) * 0.12, 
                            oy: -(y - canvas.height / 2) * 0.12, 
                            oz: 3 + Math.random() * 2,
                            r: 1.0, g: 1.0, b: 1.0 
                        });
                    }
                }
            }
        }
        precomputeGeometry();

        class Rocket {
            constructor(startX, startZ) {
                const headGeo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3));
                const headMat = new THREE.PointsMaterial({ color: 0xffffff, size: 3, blending: THREE.AdditiveBlending });
                this.mesh = new THREE.Points(headGeo, headMat);
                this.mesh.position.set(startX, -110, startZ); 
                scene.add(this.mesh);
                this.speedY = 3.8 + Math.random() * 0.5; 
                this.vx = (Math.random() - 0.5) * 0.3; this.vz = (Math.random() - 0.5) * 0.3;
                this.active = true;
                this.trailParticles = [];
                this.trailGeo = new THREE.BufferGeometry();
                const maxTrail = 1500;
                this.trailPositions = new Float32Array(maxTrail * 3);
                this.trailColors = new Float32Array(maxTrail * 3);
                this.trailGeo.setAttribute('position', new THREE.BufferAttribute(this.trailPositions, 3));
                this.trailGeo.setAttribute('color', new THREE.BufferAttribute(this.trailColors, 3));
                this.trailMat = new THREE.PointsMaterial({ size: 1.2, vertexColors: true, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
                this.trailMesh = new THREE.Points(this.trailGeo, this.trailMat);
                scene.add(this.trailMesh);
            }
            update() {
                if (!this.active) {
                    this.updateTrail(false);
                    if (this.trailParticles.length === 0) { scene.remove(this.trailMesh); return 'DONE'; }
                    return 'FADING';
                }
                this.speedY *= 0.96; this.vx *= 0.95; this.vz *= 0.95;
                this.mesh.position.y += this.speedY; this.mesh.position.x += this.vx; this.mesh.position.z += this.vz;
                this.mesh.position.x += (Math.random() - 0.5) * 0.1;
                this.updateTrail(true);
                if (this.speedY < 0.15) { scene.remove(this.mesh); this.active = false; return 'REACHED_PEAK'; }
                return 'FLYING';
            }
            updateTrail(spawnNew) {
                if (spawnNew) {
                    const count = Math.floor(this.speedY * 2) + 1;
                    for(let i=0; i<count; i++) {
                        this.trailParticles.push({
                            x: this.mesh.position.x + (Math.random()-0.5)*0.5, y: this.mesh.position.y + (Math.random()-0.5)*0.5, z: this.mesh.position.z + (Math.random()-0.5)*0.5,
                            life: 1.0, vx: this.vx * 0.2 + (Math.random()-0.5)*0.1, vy: -0.05 - Math.random()*0.05, vz: this.vz * 0.2 + (Math.random()-0.5)*0.1
                        });
                    }
                }
                let c = 0; const pos = this.trailMesh.geometry.attributes.position.array; const col = this.trailMesh.geometry.attributes.color.array;
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const p = this.trailParticles[i];
                    p.life -= 0.03; p.x += p.vx; p.y += p.vy; p.z += p.vz;
                    if (p.life <= 0) this.trailParticles.splice(i, 1);
                    else {
                        const idx = c*3; pos[idx] = p.x; pos[idx+1] = p.y; pos[idx+2] = p.z;
                        col[idx] = col[idx+1] = col[idx+2] = p.life * 0.8; c++;
                    }
                }
                this.trailMesh.geometry.setDrawRange(0, c);
                this.trailMesh.geometry.attributes.position.needsUpdate = true;
                this.trailMesh.geometry.attributes.color.needsUpdate = true;
            }
        }

        class Explosion {
            constructor(centerPos) {
                this.centerPos = centerPos;
                this.particles = [];
                const geometry = new THREE.BufferGeometry();
                const positions = []; const colors = [];
                
                const setupParticle = (pRaw, isText) => {
                    const targetX = pRaw.ox + centerPos.x;
                    const targetY = pRaw.oy + centerPos.y;
                    const targetZ = pRaw.oz + centerPos.z;
                    const spread = 20;
                    const startX = centerPos.x + (Math.random() - 0.5) * spread;
                    const startY = centerPos.y + (Math.random() - 0.5) * spread;
                    const startZ = centerPos.z + (Math.random() - 0.5) * spread;
                    
                    positions.push(startX, startY, startZ);
                    colors.push(pRaw.r, pRaw.g, pRaw.b);

                    const explosionForce = 0.15; 
                    const forceVariation = 0.8 + Math.random() * 0.4;
                    const noise = 0.7;

                    this.particles.push({
                        tx: targetX, ty: targetY, tz: targetZ,
                        cx: startX, cy: startY, cz: startZ,
                        vx: (pRaw.ox * explosionForce * forceVariation) + (Math.random()-0.5)*noise, 
                        vy: (pRaw.oy * explosionForce * forceVariation) + (Math.random()-0.5)*noise, 
                        vz: (pRaw.oz * explosionForce * forceVariation) + (Math.random()-0.5)*noise, 
                        life: 0.8 + Math.random() * 0.7, 
                        myFriction: isText ? 0.95 : (0.92 + Math.random() * 0.04)
                    });
                };

                heartPointsRaw.forEach(p => setupParticle(p, false));
                textPointsRaw.forEach(p => setupParticle(p, true));

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                this.material = new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true, opacity: 0.1, blending: THREE.AdditiveBlending, depthWrite: false });
                this.mesh = new THREE.Points(geometry, this.material);
                scene.add(this.mesh);
                this.gravity = -0.06;
                this.phase = 'forming';
                this.formTimer = 0;
            }

            update() {
                const pos = this.mesh.geometry.attributes.position.array;
                
                if (this.phase === 'forming') {
                    this.formTimer++;
                    if (this.material.opacity < 1) this.material.opacity += 0.08;
                    const lerpFactor = 0.15; let maxDist = 0;
                    for (let i = 0; i < this.particles.length; i++) {
                        const p = this.particles[i];
                        p.cx += (p.tx - p.cx) * lerpFactor;
                        p.cy += (p.ty - p.cy) * lerpFactor;
                        p.cz += (p.tz - p.cz) * lerpFactor;
                        pos[i*3] = p.cx; pos[i*3+1] = p.cy; pos[i*3+2] = p.cz;
                        const dist = Math.abs(p.tx - p.cx) + Math.abs(p.ty - p.cy) + Math.abs(p.tz - p.cz);
                        if (dist > maxDist) maxDist = dist;
                    }
                    this.mesh.geometry.attributes.position.needsUpdate = true;
                    if (maxDist < 0.5 || this.formTimer > 25) this.phase = 'hovering';
                    return true;
                } 
                else if (this.phase === 'hovering') {
                     this.mesh.position.y += 0.02; this.mesh.position.x += Math.sin(Date.now() * 0.001) * 0.02; this.mesh.rotation.y += 0.001; 
                     return true;
                }
                else if (this.phase === 'exploding') {
                    let active = 0;
                    for (let i = 0; i < this.particles.length; i++) {
                        const p = this.particles[i];
                        if (p.life > 0) {
                            p.vx *= p.myFriction; p.vy *= p.myFriction; p.vz *= p.myFriction; 
                            p.vy += this.gravity;
                            p.cx += p.vx; p.cy += p.vy; p.cz += p.vz;
                            pos[i*3] = p.cx; pos[i*3+1] = p.cy; pos[i*3+2] = p.cz;
                            p.life -= 0.01; active++;
                        } else pos[i*3] = 99999;
                    }
                    this.mesh.geometry.attributes.position.needsUpdate = true;
                    if(active < this.particles.length/2) this.material.opacity *= 0.97;
                    return active > 0 && this.material.opacity > 0.05;
                }
            }
            triggerExplode() { this.phase = 'exploding'; }
            dispose() { scene.remove(this.mesh); this.mesh.geometry.dispose(); this.material.dispose(); }
        }

        class FireworkController {
            constructor(startX, startZ) {
                this.rocket = new Rocket(startX, startZ);
                this.explosion = null; this.mainPhase = 'LAUNCH'; this.timer = 0; this.isDead = false;
            }
            update() {
                if (this.mainPhase === 'LAUNCH') {
                    if (this.rocket.update() === 'REACHED_PEAK') { this.explosion = new Explosion(this.rocket.mesh.position); this.mainPhase = 'DISPLAY'; this.timer = 0; }
                } else if (this.mainPhase === 'DISPLAY') {
                    this.rocket.update(); if (this.explosion) this.explosion.update();
                    this.timer++; 
                    if (this.timer > 50) { this.explosion.triggerExplode(); this.mainPhase = 'EXPLODE_FINISH'; }
                } else if (this.mainPhase === 'EXPLODE_FINISH') {
                    this.rocket.update();
                    if (this.explosion && !this.explosion.update()) { this.explosion.dispose(); this.explosion = null; this.mainPhase = 'DONE'; }
                } else if (this.mainPhase === 'DONE') {
                    if (this.rocket.update() === 'DONE') this.isDead = true;
                }
            }
        }

        const activeFireworks = []; let frameCount = 0;
        const starGeo = new THREE.BufferGeometry(); const starPos = []; for(let i=0; i<2000; i++) starPos.push((Math.random()-0.5)*1500, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0x888888, size: 0.5}));
        scene.add(stars);

        function animate() {
            requestAnimationFrame(animate);
            stars.rotation.y -= 0.0003; frameCount++;

            if (frameCount === 10) activeFireworks.push(new FireworkController(0, 0));
            if (frameCount === 100) activeFireworks.push(new FireworkController(-50, -20));
            if (frameCount === 200) activeFireworks.push(new FireworkController(50, 20));
            if (frameCount > 300 && frameCount % 80 === 0) {
                activeFireworks.push(new FireworkController((Math.random()-0.5)*140, (Math.random()-0.5)*60));
            }

            for (let i = activeFireworks.length - 1; i >= 0; i--) {
                activeFireworks[i].update();
                if (activeFireworks[i].isDead) activeFireworks.splice(i, 1);
            }
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>